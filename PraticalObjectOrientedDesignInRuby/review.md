<!-- markdownlint-disable MD025 MD036 MD041 -->

![Practical Obejct Oriented In Ruby](cover.jpg)

# 한줄평

객체지향 설계 디자이너를 위한 실용서.

# 책소개

`루비로 배우는 객체지향 디자인` 이 책의 부제는 지속가능한 소프트웨어를 만드는 방법이다. 원제는 번역된 문구와 비슷하지만 부제는 다르다. 원제는 `Practical Object-Oriented Design in Ruby`이고 부제는 `AN AGILE PRIMER`이다. 원제를 직역하면 "루비로 된 실용적인 객체지향 디자인: 애자일 초보"라고 할 수 있는데 지속가능한 소프트웨어를 만드는 방법이라는 국문판 부제가 원서 부제보다 내용에 잘 어울린다고 생각한다.

2013년도에 원서가 출판되었고 번역서는 1년 뒤인 2014년도에 출판되었다. 저자는 샌디 메츠(Sandi Metz)님이다. 저자의 홈페이지([샌디메츠 홈페이지](https://www.sandimetz.com/about))에 보면 직업을 선생님, 작가, 컨설턴트로 소개하는데 직업들을 보니 저자가 설명을 잘하는게 수긍이 된다. 번역도 잘되어 매끄럽게 읽히는 것 같다. 번역은 박건한님이다.

# 감상평

책 제목만 보고 루비를 모르면 이해하기 힘들겠다고 생각했는데 충분히 이해할 수 있게 구성되어 있다. 직설적으로 말하는 듯한 글이라 더 와닿는 느낌이었다. 또한 책의 내용 구성도 문제에 부딪히고 그걸 해결해 가는 과정을 보여줌으로서 주제를 이해하는데 큰 도움이 된다. 하나 더 좋았던 점은 문제나 해결방안을 바라보는 사고과정이나 그 안에 담겨 있던 생각들이 자주 나온다. 건조하게 해결법과 근거만을 설명하는게 아니라 머릿속에서 생각의 흐름을 알 수 있게 해 줘서 더 빠르게 책에 몰입하게 해 줬다.

> 디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

이 주장이 저자가 핵심적으로 하고 싶은 말이라고 볼 수 있다. 그리고 읽다 보면 저자가 이 내용을 자주 언급해서 자연스럽게 이게 저자가 하고 싶은 말이었다는 걸 알게 된다.

이 책은 객체지향을 고민하는 사람이거나 입문하는 사람에게 적극 추천한다. 그리고 이 책과 더불어 `객체지향의 사실과 오해`를 읽는다면 이 책에서 말하는 `메시지`, `역할`, `책임`의 이해를 넓힐 수 있다고 생각한다. 특히 이 책은 코드 사례를 효과적으로 활용하면서 설명하기 때문에 실제 코딩할 때도 도움이 많이 될 것 같다.

# 각장 요약

## 1장 객체지향 디자인

* 객체지향 소프트웨어는 이 세계를 객체 사이의 자발적인 상호연관의 연속으로 파악한다.
* 디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.
* 애자일 작업방식은 변화를 보장한다. 그리고 코드를 수정할 수 있는 우리의 능력은 애플리케이션의 디자인에 달려있다.
* 애자일은 디자인을 거부하지 않는다. 디자인을 필요로 한다. 디자인을 필요로 할 뿐 아니라, 진자 좋은 디자인을 필요로 한다. 우리가 만들 수 있는 최상의 디자인이 필요하다.  간단하고 유연하며 내 마음대로 조작할 수 있는 코드가 꼭 필요하다.
* 경험이 부족한 프로그래머라면 지나치게 미래를 많이 예상하고 이런 예상을 담은 디자인을 만들 것이다. 이런 디자인에 들은 노력은 결코 그 값어치를 하지 않는다.
* 능력 있는 디자이너가 오늘 아침에 조심스럽게 작성한 코드는 오늘 저녁의 개발 비용을 낮출 수 있을 것이다.
* 대부분의 프로그래머는 이 두 극단 사이 어딘가에 위치해 있다.
* 변화를 손쉽게 받아들일 수 있도록 코드를 배치하는 일, 이것이 디자인이다. 디자인에서 가장 눈에 띄는 요소는 원칙과 패턴이다. 하지만 원칙을 올바르게 적용하고 적절한 패턴을 사용해도 수정하기 쉬운 애플리케이션을 만들었다고 확신할 수는 없다.

## 2장 단일 책임 원칙을 따르는 클래스 디자인하기

* 어떤 클래스를 만들어야 할까? 몇 개나 만들어야 할까? 어떤 행동을 구현해야 할까? 하나의 클래스는 다른 클래스에 대해 얼마나 알고 있어야 할까? 다른 클래스에게는 어느 정도까지 열려있어야 할까? . . . 현재 시점에서 우리가 해야 하는 일은 일단 깊게 심호흡을 한 번 하고, 클래스는 다순해야 한다는 마을 명심하는 것이다.
* 우리는 이런 질문들에 압도 당한다. 모든 결정은 위험으로 가득 차 있고 한번 결정한 것은 되돌릴 수 없을 것 같다. 하지만 두려워 말자. 현재 시점에서 우리가 해야 하는 일은 일단 깊게 심호흡을 한 번 하고, **클래스는 단순해야 한다**는 말을 명심하는 것이다.
* `데이터 구조를 들여다보던 작업`을 `객체에 대한 메시지를 전송`으로 대체한다.
* 최종적인 디자인을 모르는데도 이런 리팩터링을 해야 하는 걸까? 필요하다. 리팩터링은 디자인이 명확하기 때문에 필요한 것이 아니라 오히려 디자인이 불명확하기 때문에 필요한 것이다.
* 여러 메서드가 각각 하나의 책임을 질 때 다음과 같은 이득을 얻을 수 있다.
  * 예전에 몰랐던 특성이 드러난다.
  * 주석을 넣어야 할 필요가 없어진다.
    * 주석은 실행되는 코드가 아니기 때문에 시간이 지나면 바스러지는 종이문서 같다.
    * (-> 이 말에 엄청 공감된다.)
  * 재사용을 유도한다.
  * 다른 클래스로 옮기기 쉽다.

## 3장 의존성 관리하기

* 서로 협업하려면 객체는 다른 객체에 대한 지식이 있어야 한다. `지식은 의존성을 만들어 낸다.`
* 의존성을 줄이는 작업은 곧 불필요한 본드가 무엇인지 알고 그것을 제거하는 과정이다.
* (-> 모든 본드를 제거할 순 없을 것이다. 불필요한 본드가 무엇인지 아는게 중요하다.)
* 추상화의 훌륭한 점은 일반적이고 안정적인 성질을 지닌다는 점이다.
* 절대로! 어떤 상황에서든 수정하고 싶지 않게 만든다. 모두가 이 클래스를 수정하기를 꺼려하기 때문에 우리의 애플리케이션은 영원히 코칠 수 없는 문제를 안고 간다.
* `자기 자신보다 덜 변하는 것들에 의존하라`는 이번 절에서 검토한 생각을 종합해 줄 수 있는 격언이다.
* 의존성 관리의 핵심은 그 방향을 관리하는 것이다. 평온한 유지보수라는 궁극의 목표를 향한 길은 자기 자신보다 덜 변하는 것에 의존하는 클래스들로 덮여있다.

## 4장 유연한 인터페이스 만들기

* 애플리케이션은 클래스로 구성되어 있지만 메시지를 통해 정의된다. 소스 코드 레포지토리에 무엇이 들어갈지를 결정하는 것은 클래스지만 애플리케이션의 움직임을 반영하는 것은 메시지이며 이 메시지가 애플리케이션을 살아 움직이게 한다.
* 클래스의 퍼블릭 인터페이스를 구성하는 메서드는 바깥 세상을 향한 클래스의 얼굴이다. 이런 메서드는,
  * 클래스의 핵심 책임(Primary responsibility)을 드러낸다.
  * 다른 객체에 의해 호출될 수 있다.
  * 쉽게 변경되지 않는다.
  * 다른 객체가 안정적으로 의존할 수 있다.
  * 테스트를 통해 꼼꼼하게 문서화되어 있다.
* 그 외의 메서드는 프라이빗 인터페이스의 한 부분이다. 이런 메서드는,
  * 세부적인 구현을 담당한다.
  * 다른 객체에 의해 호출되지 않는다.
  * 필요에 따라 언제든 변경할 수 있다.
  * 다른 객체가 의존하기에는 위험하다.
  * 테스트에서 다루지 않을 수도 있다.
* 자신보다 덜 변화하는 것에 의존해야 한다는 생각은 클래스 내부에도 적용된다.
* 언제나 디자인 목표는 당장의 요구사항을 처리하기에 충분한 코드를 작성하면서 나중에 수정할 수 있는 여지를 최대한 확보하는 것이다.
* `객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 때문에 객체를 갖게 된 것이다.`

## 5장 오리 타임으로 비용 줄이기

* 오리 타입은 특정 클래스에 종속되지 않는 퍼블릭 인터페이스이다.
* 오리 타입은 이 퍼블릭 인터페이스를 글래스로부터 분리해 낸다. 그리고 '객체가 누구인지'가 아니라 '객체가 무엇을 하는지'에 따라 가상의 타입을 만들어 낸다.
* **폴리모피즘(polymorphism)** 일바적인 정의는 다음과 같다.
* "Morph는 형태를 뜻하는 그리스어이다. morphism은 형태를 가지고 있는 상태를 뜻하며 polymorphism은 여러 형태를 가지고 있는 상태를 의미한다. 생물학자들이 이 단어를 사용한다. 다윈의 저 유명한 핀치새류는 폴리모픽하다. 하나의 종이 여러 형태를 가지고 있다."
* 객체지향 프로그래밍에서 사용하는 폴리모피즘은 같은 메시지에 반응할 수 있는 여러 객체의 능력을 의미한다. 결국 하나의 메시지가 여러 개의(poly) 형태(morphs)를 갖게 된다.
* `kind_of`, `is_a`, `reponds_to` 그리고 클래스에 따라 변경되는 case 구분은 모두 숨겨진 오리 타입이 있다고 말해준다. 이 모든 경우 코드는 이렇게 말하고 있다. "나는 네가 누구인지 알고 있고, 그렇기 때문에 네가 무엇을 하는지도 알고 있다." 이 지식은 협업하는 객체에 대한 믿음이 부족하다는 사실을 말해 줄 뿐이고 부족한 믿음은 협업 객체가 운신할 수 있는 폭을 줄인다. 그리고 코드를 수정하기 어렵게 만드는 의존성을 불러온다.

## 6장 상속을 이용해 새로운 행동 얻기

* 기본적으로 상속이란 자동화된 메시지 전달(automatic message delegation) 시스템이다.
* 리팩터링 전략을 선택할 때, 물론 일반적으로 디자인 전략을 선택할 때도 마찬가지인데, 다음과 같은 질문을 전져 보면 좋다. "내가 실수하면 어떤 일이 벌어질까?" 비어 있는 상위클래스를 만들고 추상화 코드를 위로 올리는 전략을 취할 때 발생할 수 있는 최악의 경우는 무엇일까? 추상화할 수 있는 코드를 하나도 찾지 못하는 것이다.
* 기본 구조를 상위클래스가 정의하고 상위클래스에서 메시지를 전송하여 하위클래스의 특수한 값을 얻는 기술을 `템플릿 메서드(template method)` 패턴이라고 부른다.
* 하위클래스가 알고리즘을 알고 있고 super를 전송하는 대신 `훅(hook)`메시지를 전송할 수 있다. 훅 메시지는 정해진 메서드 구현을 통해 하위클래스가 정보를 제공할 수 있도록 만들어 주는 메시지이다. 이 방법을 사용하면 하위클래스는 알고리즘에 대해 몰라도 되며, 상위클래스가 모든 권한을 가질 수 있게 된다.

```ruby
class Bicycle
    attr_reader :size, :chain, :tire_size
    
    def initialize(args={})
        @size = args[:size]
        @chain = args[:chain] || defualt_chain
        @tire_size = args[:tire_size] || default_tire_size
        post_initialize(args)
    end

    def spares
        { tire_size: tire_size,
          chain: chain}.merge(local_spares)
    end

    def default_tire_size
        raise NotImplementedError
    end

    # 하위클래스가 재정의 할 수 있다.
    def post_initialize(args)
        nil
    end

    def local_spares
        {}
    end

    def default_chain
        '10-speed'
    end
end

class RoadBike < Bicycle
    attr_reader :tape_color

    def post_initialize(args)
        @tape_color = args[:tape_color]
    end

    def local_spares
        {tape_color: tape_color}
    end

    def default_tire_size
        '23'
    end
end

class MountainBike < Bicycle
    attr_reader :front_shock, :rear_shock

    def post_initialize(args)
        @front_shock = args[:front_shock]
        @rear_shock = args[:rear_shock]
    end

    def local_spares
        {rear_shock: rear_shock}
    end

    def default_tire_size
        '2.1'
    end
end
```

* RoadBike와 MountainBike는 구체적인 구현만 가지고 있기 때문에 훨씬 읽기 쉽다. 한눈에 훑어봐도 이 클래스가 어떤 일을 하는지 알 수 있고 Bicycle의 특수한 형태라는 것도 명확하다.
* 새로운 하위 클래스는 탬플릿 메서드만 구현하고 있으면 된다. 마시작 예시는 애플리케이셔에 익숙하지 않은 사람에게도 새로운 하위클래스를 만드는 것이 얼마나 간단한지 보여준다. RecumbentBike클래스는 Bicycle의 새로운 형태, 특수한 형태이다.

```ruby
class RecumbentBike < Bicycle
    attr_reader :flag

    def post_initialize(args)
        @flag = args[:flag]
    end

    def local_spares
        {flag: flag}
    end

    def defulat_chain
        "9-speed"
    end

    def default_tire_size
        '28'
    end
end

bent = RecumbentBike.new(flag: 'tall and orange')
bent.spares
# -> {:tire_size => "28",
#     :chain     => "10-speed",
#     :flag      => "tall and orange"}
```

* 이번 장의 간단한 예시는 두 개의 클래스르 가지고 작업했지만 실생활에서는 세 개의 타입이 제공하는 충분한 정보를 얻을 때까지 기다리는 것이 더 좋을 수 있다.

## 7장 모듈을 통한 역할 공유

* 어떤 문제들은 ㅇ 문제를 해결하기 위해서가 아니라면 별로 연관이 없는 개체들이 공통의 행동을 공유하게 만든다. 이런 공통의 행동은 클래스와 아무런 상관이 없다. 이 행동은 객체가 수행하는 **역할(role)** 이다.
* 우리는 두 가지를 결정해야 한다. 코드가 무엇을 해야 하는지, 그리고 코드를 어디에 두어야 하는지. 일을 시작하기 가장 좋은 출발점은 이 두 결정을 분리해서 다루는 것이다.
* 이번 장은 '고전적 상속'과 '모듈을 통한 코드 공유' 사이의 구분을 유지하기 위해 노력해왔다. 상속인 것과 상속처럼 행동하는 것의 차이는 분명 중요하다.