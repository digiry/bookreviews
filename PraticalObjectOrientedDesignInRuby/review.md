<!-- markdownlint-disable MD025 MD036 MD041 -->

![Practical Obejct Oriented In Ruby](cover.jpg)

# 한줄평

객체지향 설계 디자이너를 위한 실용서.

# 책소개

`루비로 배우는 객체지향 디자인` 이 책의 부제는 지속가능한 소프트웨어를 만드는 방법이다. 원제는 번역된 문구와 비슷하지만 부제는 다르다. 원제는 `Practical Object-Oriented Design in Ruby`이고 부제는 `AN AGILE PRIMER`이다. 원제를 직역하면 "루비로 된 실용적인 객체지향 디자인: 애자일 초보"라고 할 수 있는데 지속가능한 소프트웨어를 만드는 방법이라는 국문판 부제가 원서 부제보다 내용에 잘 어울린다고 생각한다.

2013년도에 원서가 출판되었고 번역서는 1년 뒤인 2014년도에 출판되었다. 저자는 샌디 메츠(Sandi Metz)님이다. 저자의 홈페이지([샌디메츠 홈페이지](https://www.sandimetz.com/about))에 보면 직업을 선생님, 작가, 컨설턴트로 소개하는데 직업들을 보니 저자가 설명을 잘하는게 수긍이 된다. 번역도 잘되어 매끄럽게 읽히는 것 같다. 번역은 박건한님이다.

# 감상평

책 제목만 보고 루비를 모르면 이해하기 힘들겠다고 생각했는데 충분히 이해할 수 있게 구성되어 있다. 직설적으로 말하는 듯한 글이라 더 와닿는 느낌이었다. 또한 책의 내용 구성도 문제에 부딪히고 그걸 해결해 가는 과정을 보여줌으로서 주제를 이해하는데 큰 도움이 된다. 하나 더 좋았던 점은 문제나 해결방안을 바라보는 사고과정이나 그 안에 담겨 있던 생각들이 자주 나온다. 건조하게 해결법과 근거만을 설명하는게 아니라 머릿속에서 생각의 흐름을 알 수 있게 해 줘서 더 빠르게 책에 몰입하게 해 줬다.

> 디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.

이 주장이 저자가 핵심적으로 하고 싶은 말이라고 볼 수 있다. 그리고 읽다 보면 저자가 이 내용을 자주 언급해서 자연스럽게 이게 저자가 하고 싶은 말이었다는 걸 알게 된다.

이 책은 객체지향을 고민하는 사람이거나 입문하는 사람에게 적극 추천한다. 그리고 이 책과 더불어 `객체지향의 사실과 오해`를 읽는다면 이 책에서 말하는 `메시지`, `역할`, `책임`의 이해를 넓힐 수 있다고 생각한다. 특히 이 책은 코드 사례를 효과적으로 활용하면서 설명하기 때문에 실제 코딩할 때도 도움이 많이 될 것 같다.

# 내용 갈무리

## 1장 객체지향 디자인

* 객체지향 소프트웨어는 이 세계를 객체 사이의 자발적인 상호연관의 연속으로 파악한다.
* 디자인은 나중에 디자인할 수 있는 여지를 남겨 놓기 위한 것이고, 그 최종 목표는 변화의 비용을 최소화하는 것이다.
* 애자일 작업방식은 변화를 보장한다. 그리고 코드를 수정할 수 있는 우리의 능력은 애플리케이션의 디자인에 달려있다.
* 애자일은 디자인을 거부하지 않는다. 디자인을 필요로 한다. 디자인을 필요로 할 뿐 아니라, 진자 좋은 디자인을 필요로 한다. 우리가 만들 수 있는 최상의 디자인이 필요하다.  간단하고 유연하며 내 마음대로 조작할 수 있는 코드가 꼭 필요하다.
* 경험이 부족한 프로그래머라면 지나치게 미래를 많이 예상하고 이런 예상을 담은 디자인을 만들 것이다. 이런 디자인에 들은 노력은 결코 그 값어치를 하지 않는다.
* 능력 있는 디자이너가 오늘 아침에 조심스럽게 작성한 코드는 오늘 저녁의 개발 비용을 낮출 수 있을 것이다.
* 대부분의 프로그래머는 이 두 극단 사이 어딘가에 위치해 있다.
* 변화를 손쉽게 받아들일 수 있도록 코드를 배치하는 일, 이것이 디자인이다. 디자인에서 가장 눈에 띄는 요소는 원칙과 패턴이다. 하지만 원칙을 올바르게 적용하고 적절한 패턴을 사용해도 수정하기 쉬운 애플리케이션을 만들었다고 확신할 수는 없다.

저자는 1장에서 객체지향 디자인이라는 것을 설명한다. `객체 사이의 자발적인 상화연관의 연속으로 파악한다`라는 말은 객체 자체를 만드는 것에 초점을 맞췄던 내가 잘못 생각하고 있다고 알려 주고 있다. 또한 객체가 주고 받는 메시지가 중요하다는 걸 `객체지향의 사실과 오해`에서도 동일하게 주장한다.

이 장에서 기억 남는 것이 `디자이너`라는 단어다. 디자이너는 설계만 하는 사람을 말하지 않고 설계를 하고 코딩까지 하는 사람을 말하는 것 같다. 사실 설계자와 코딩하는 사람을 완벽히 구분하는 건 어렵다고 생각한다. 그건 설계와 코딩이라는 과정이 독립적이지 않고 설계, 코딩, 개선이라는 게 하나의 주기로 반복되기 때문이다. 이 말은 맨먼스미신에서 브룩스 교수님이 말한 것과 동일하다.

## 2장 객체지향 디자인

* 어떤 클래스를 만들어야 할까? 몇 개나 만들어야 할까? 어떤 행동을 구현해야 할까? 하나의 클래스는 다른 클래스에 대해 얼마나 알고 있어야 할까? 다른 클래스에게는 어느 정도까지 열려있어야 할까?
* 우리는 이런 질문들에 압도 당한다. 모든 결정은 위험으로 가득 차 있고 한번 결정한 것은 되돌릴 수 없을 것 같다. 하지만 두려워 말자. 현재 시점에서 우리가 해야 하는 일은 일단 깊게 심호흡을 한 번 하고, **클래스는 단순해야 한다**는 말을 명심하는 것이다.
* 문제는 기술에 대한 지식이 아니라 코드를 구성하고 배치하는 일이다. 우리는 코드를 짤 줄은 알지만 그것들은 어디에 어떻게 놓아야 하는지는 모르고 있다.
* 우리에게는 수정하기 쉬움에 대한 명확한 정의가 필요하고 코드를 평가하기 위한 구체적인 기준이 필요하다.
  * 수정이 예상치 못한 부작용을 낳지 않는다.
  * 요구사항이 조금 변했을 때 연관된 코드들을 조금만 수정하면 된다.
  * 현재 코드를 다시 사용하기 쉽다.
  * 코드를 수정하는 가장 쉬운 방법은 이미 수정하기 쉬운 코드에 새로운 코드를 추가하는 것이다.
* 우리가 작성하는 코드는 다음과 같은 특징이 있어야 한다.
  * 투명하다(Transparent): 수정된 코드 속에서 그리고 이 코드와 연관된 코드 속에서, 수정의 결과가 뚜렷하게 드러나야 한다.
  * 적절하다(Reasonable): 모든 수정 비용은 수정 결과를 통해 얻은 이득에 비례해야 한다.
  * 사용가능하다(Usable): 예상치 못한 새로운 상황에서도 현재 코드를 사용할 수 있어야 한다.
  * 모범이 된다.(Exemplary): 코드 자체가 나중에 수정하는 사람이 위의 특징을 이어갈 수 있게 도와줘야 한다.
* 이런 코드를 짜기 위한 첫 단추는 모든 클래스들이 하나의, 잘 정의된 책임을 갖도록 하는 일이다.
* 클래스의 책임이 너무 밀접하게 결합되어(coupled) 있어서 우리가 원하는 행동만 가져 올 수 없을 때 코드를 복사해서 사용하는 방법이 있다. 이건 끔찍한 발상이다. 복사해서 붙여 넣은 중복코드는 유지보수를 어렵게 하고 버그를 만들어 낸다.
* 클래스가 다른 클래스의 책임까지 짊어지고 있는지 어떻게 알 수 있을까? 한 가지 방법은 클래스를 인격이 있는 존재처럼 가정하고 질문을 던져보는 방법이다. 클래스가 구현하고 있는 모든 메서드를 하나씩 질문 형태로 바꾸면 말이 되는 질문이 만들어져야 한다.
* 예를 들어, "Gear씨, 당신의 기어비는 무엇인가요?"는 말이 된다. 반면 "Gear씨, 당신의 기어 인치는 무엇인가요?"라는 질문은 조금 애매하다.
* 클래스가 진짜 하는 일이 무엇인지 알아낼 수 있는 또 다른 방법은 클래스의 책임을 한 문장으로 만들어 보는 것이다. 클래스는 '최대한 작으면서도 유용한 것(smallest possible useful thing)'만 행해야 한다는 것을 기억하자.
* 단일 책임 원칙은 크래스가 매우 협소한 한 가지 역할만 해야 한다고 말하는 것이 아니다. 또는 사소한 수정만 해야 한다고 말하는 것도 아니다. 클래스가 응집되어 있어야 한다는 말하는 것이다. 다시 말해서, 클래스의 모든 활동은 그 존재 이유와 밀접히 연관되어 있어야 한다.
* '지금 당장 개선하기'와 '나중에 개선하기' 사이에는 언제나 긴장감이 흐른다. 완벽하게 디자인된 애플리케이션이란 없다. 모든 결정에는 대가가 따른다. 좋은 디자이너는 이 긴장을 이행하고 당장의 필요와 미래의 가능성 사이에 심사숙고하여 개선비용을 최소화한다.
* 변수를 직접 참조하기보다는 언제나 엑세서 메서드를 통해 변수에 접근하는 것이 좋다.
* 데이터를 마치 `메시시를 이해하는 객체`처럼 취급하는 것은 두 가지 새로운 이슈를 낳는다.
  * 첫 번째 이슈는 가시성(visibility)에 관한 것이다
  * 두 번째 이슈는 좀 더 추상적이다. 모든 변수를 래퍼 메서드로 감싸고 변수를 마치 객체처럼 사용할 수 있기 떄문에 데이터와 객체 사이의 구분이 무의미해진다.
* 개발자 자신으로부터도 데이터를 감추는 편이 좋다. 이를 통해 예상치 못한 변화로부터 코드를 보호할 수 있다. 개발자도 데이터의 모든 행동을 다 알고 있지 못한 경우가 많다. 개발자가 변수를 데이터처럼 생각하고 있더라도 변수는 메시지를 통해 접근하자.

```ruby
class ObscuringReferences
    attr_reader :data
    def initialize(data)
        @data = data
    end

    def diameters
        # 0은 바퀴지름(rim), 1은 타이어 높이(tire)
        data.collect {|cell|
            cell[0] + (cell[1] * 2)}
    end
```

```ruby
# 밀리미터로 표시된 바퀴지름과 타이어 높이의 2차원 배열
@data = [[622, 20], [622, 23], [559, 30], [559,40]]
```

* `@data`가 복잡한 데이터 구조를 가지고 있기 때문에, 단순히 이뇨스턴스 변수를 감추는 것으로는 충분하지 않다. 이 배열을 가지고 뭔가 쓸모 있는 작업을 하려면, data 메서드를 전송하는 객체는 배열의 어느 위치에 어떤 데이터가 들어있는지 모두 알고 있어야 한다.
* `이런 지식은 배열의 구조에 의존적이다.`
* `변수의 캡슐화를 무시하고 배열 구조에 대한 지식을 코드 이곳저곳에 흩뿌려 놓는다.` 전혀 DRY 하지 않다. 바퀴테 지름을 `[0]`에서 찾을 수 있다는 지식은 중복되어서는 안 된다. 이런 지식은 단 한 곳에서 관리해야 한다.
* 복잡한 구조를 직접 참조하면 진짜 데이터가 무엇인지 드러나지 않기 때문에 우리를 헷갈리게 한다.

```ruby
class RevealingReferences
    attr_reader :wheels
    def initialize(data)
        @wheels = wheelify(data)
    end

    def diameters
        wheels.collect {|wheel|
            wheel.rim + (wheel.tire * 2)}
    end
    # ...

    Wheel = Struct.new(:rim, :tire)
    def wheelify(data)
        data.collect {|cell|
            Wheel.new(cell[0], cell[1])}
    end
```

* `데이터 구조를 들여다보던 작업`을 `객체에 대한 메시지를 전송`으로 대체한다.
* 개별 객체에 행해지는 액션과 객체들을 훓는 활동(iteration)을 분리하는 것은 쉽게 발견할 수 있는 중복 책임의 예이다.
* 최종적인 디자인을 모르는데도 이런 리팩터링을 해야 하는 걸까? 필요하다. 리팩터링은 디자인이 명확하기 때문에 필요한 것이 아니라 오히려 디자인이 불명확하기 때문에 필요한 것이다.
* 여러 메서드가 각각 하나의 책임을 질 때 다음과 같은 이득을 얻을 수 있다.
  * 예전에 몰랐던 특성이 드러난다.
  * 주석을 넣어야 할 필요가 없어진다.
    * 주석은 실행되는 코드가 아니기 때문에 시간이 지나면 바스러지는 종이문서 같다.
    * (-> 이 말에 엄청 공감된다.)
  * 재사용을 유도한다.
  * 다른 클래스로 옮기기 쉽다.
* 우리의 목표는 최대한 특정 디자인에 종속되지 않으면서, Gear가 하나의 책임만을 지도록 하는 것이다. 왜냐하면 수정하기 쉬운 코드를 작성하려면 진짜 어쩔 수 없는 순간이 올 때까지 최대한 디자인 결정을 미루는 것이 좋기 떄문이다.
* 자전거를 타는 친구에게 우리의 계산 프로그램을 다시 보여줬고 친구는 이 프로그램이 매우 훌륭하지만 `자전거 바퀴 둘레(circumference)`를 계산하는 기능도 필요하다고 말한다. ... 이 정보야 말로 우리가 기다리는 정보다. 이 새로운 기능추가 요청은 다음 디자인 결정을 내리는 데 필요한 정보를 제공해준다.
* 바퀴의 둘레는 지름 곱하기 원주율이다. 지름을 계산할 줄 아는 Wheel을 Gear안에 넣어 두었기에 둘레를 계산하는 메서드를 추가하는 것은 아주 쉽다.
* 진짜 중요한 변화는 우리의 애플리케이션에 Gear클래스와는 독립된 Wheel 클래스가 명시적으로 필요해졌다는 점이다.

## 3장 의존성 관리하기

* 서로 협업하려면 객체는 다른 객체에 대한 지식이 있어야 한다. `지식은 의존성을 만들어 낸다.`

```ruby
class Gear
    attr_reader :chainring, :cog, :rim, :tire
    def initiakklize(chainring, cog, rim, tire)
        @chainring = chainring
        @cog = cog
        @rim = rim
        @tire = tire
    end

    def gear_inches
        ratio * Wheel.new(rim. tire).diameter
    end

    def ratio
        chainring / cog.to_f
    end
    # ...
end

class Wheel
    attr_reader :rim, :tire
    def initialize(rim, tire)
        @rim = rim
        @tire = tire
    end

    def diameter
        rim + (tire * 2)
    end
    # ...
end

Gear.new(52, 11, 26, 1.5).gear_inches
```

* 적어도 네 군데에서 의존성이 있다.
  1. 다른 클래스의 이름. Gear는 Wheel이라는 이름의 클래스가 있다는 걸 알고 있다.
  2. 자기 자신을 제외한 다른 객체에게 전송할 메시지의 이름. Gear는 Wheel의 인스턴스가 diameter라는 메서드를 이해할 수 있다는 것을 알고 있다.
  3. 메시지가 필요로 하는 인자들. Gear는 Wheel.new를 위해 rim과 tire를 인자로 넘겨야 한다는 것을 알고 있다.
  4. 인자들을 전달하는 순서. Gear는 Wheel.new의 첫 번쨰 인자가 rim이고 두번째 인자가 tire라는 것을 알고 있다.
* 위에 나열한 의존성은 대부분은 불필요하다. 불필요한 의존성은 코드를 덜 적절하게(reasonable) 만든다. 왜냐하면 이 의존성이 Gear클래스의 수정을 강제한다.

* 일발적인 의존성 이슈들
  * 여러 개의 메시지가 여러 단계를 거쳐 연결되어(chained) 저 멀리 있는 객체의 행동을 실행시키려 할 때 가장 심각한 피해를 야기하는 의존성이 그 모습을 드러낸다. 이 의존성은 기본적으로 `자기 자신을 제외한 다른 객체에게 전송할 메시지의 이름을 아는` 의존성이다. ... 이런 경우를 데메테르의 원칙(Law of Demeter)이 위반되었다고 한다.
  * 의존성의 또 다른 영역은 테스트가 코드에 대해 갖는 의존성이다. 테스트-코드 사이의 지나친 결합은 코드-코드 사이의 지나친 결합과 같은 결과를 낳는다. 이 결합은 코드의 수정이 뒤이어 테스트의 수정을 강제하는 의존성이다.
* 의존성을 줄이는 작업은 곧 불필요한 본드가 무엇인지 알고 그것을 제거하는 과정이다.
* (-> 모든 본드를 제거할 순 없을 것이다. 불필요한 본드가 무엇인지 아는게 중요하다.)

```diff
class Gear
    attr_reader :chainring, :cog, :rim, :tire
-    def initialize(chainring, cog, rim, tire)
+    def initialize(chainring, cog, wheel)
        @chainring = chainring
        @cog = cog
-        @rim = rim
-        @tire = tire
+        @wheel = wheel
    end

    def gear_inches
-        ratio * Wheel.new(rim. tire).diameter
+        ratio * wheel.diameter
    end

    def ratio
        chainring / cog.to_f
    end
    # ...
end
```

* Gear는 @wheel 변수를 사용하고 wheel 메서드로 변수에 접근한다. 하지만 속지말자. Gear는 @wheel 클래스가 Wheel 클래스의 인스턴스라는 것을 알지도 못하고 관심도 없다. Gear가 알고 있는 것은 자기 자신이 diameter 메서드에 반응할 줄 아는 객체를 가지고 있다는 것뿐이다.
* Wheel 인스턴스를 Gear 클래스 바깥에서 생성하기 때문에 Gear와 Wheel 사이의 결합이 없어졌다. `이제 Gear는 diameter를 구현하고 있는 어떤 객체와도 협업할 수 있게 되었다.`
* 이 기술을 `의존성 주입(dependency injection)`이라고 부른다. ... Gear는 Wheel 클래스, Wheel을 초기화 할 때 넘겨줘야 하는 인자와 인자의 순서에 대해 명시적으로 의존하고 있었지만 의존성 주입을 통해 이 모든 의존성이 diameter 메서드에 대한 단 하나의 의존성으로 줄어들었다. Gear는 아는 것이 적어졌기 때문에 더 똑똑해 졌다.
* 만약 제약조건이 너무 많아서 Gear에 Wheel을 주입(inject)할 수 없다면 새로운 Wheel 인스턴스를 만드는 과정을 Gear 클래스 내부에 격리시켜 놓을 필요가 있다.
